#!/usr/bin/perl -Tw

require 5.008; # for proper UTF-8 handling in parser
use Date::Format;
use HTML::Parser;
use LWP::RobotUA;
use LWP::UserAgent;
use URI;
use strict;

=pod

=head1 NAME linkcheck

=head1 SYNOPSIS
  linkcheck [URL]

=head1 DESCRIPTION

  Link checker.

=cut

if (!@ARGV) {
    print "Usage: $0 [URL] ...\n";
    exit(1);
}    

my @todo = map {URI->new($_)} @ARGV;
my $myhost = $todo[0]->host();
my $myscheme = $todo[0]->scheme();
my $myport = $todo[0]->port();
my %done;
my %linker;
my $url;
my $mymail;
my $count = 0;
my $robot;
my $result;

my $ua = LWP::UserAgent->new;
my $parser = HTML::Parser->new(api_version => 3,
                               start_h     => [\&start, "tagname, attr"]);
$parser->utf8_mode(1);

while (@todo) {
    $url = shift(@todo);
    next if $done{$url};
    if ($count > 50_000) {
        print STDERR "More than 50,000 pages on site.\n";
        exit(1);
    }

    if ($count > $#ARGV and !$mymail) {
        print STDERR qq{No email address in mailto or <link rev="made">.\n};
        print STDERR "Add an address to enable crawling.\n";
        print STDERR "$count pages fetched.\n";
        exit(1);
    }

    my $req = HTTP::Request->new(GET => $url);
    my $result;
    if ($mymail) {
        if (!$robot) {
            $robot = LWP::RobotUA->new('sitemap-o-matic/0.3', $mymail);
            $robot->delay(0);
            undef($ua);
        }
        $result = $robot->request($req);
    }
    else {
        $result = $ua->request($req);
    }

    if ($result->is_error()) {
        $done{$url}{'status'} = 'error '. $result->code;
    } elsif ($result->is_redirect()) {
         $done{$url}{'status'} = 'redirected ';
    } elsif ($result->content_type eq 'text/html' or
           $result->content_type eq 'application/xhtml+xml') {
        $parser->parse($result->content);
        $parser->eof();
        if (defined($result->last_modified())) {
            ${done}{$url}{'lastmod'} = 
                time2str("%Y-%m-%d", $result->last_modified());
        }
        $done{$url}{'status'} = 'success';
    }
    else {
        $done{$url}{'status'} = "MIME type " . $result->content_type;
    }
    $count++;
}

foreach my $page (sort keys(%done)) {
    if ($done{$page}{'status'} eq 'success') {
        $result = 0 if !defined($result);
    }

    if ($done{$page}{'status'} =~ /^error/) {
        print STDERR "$done{$page}{'status'} $page ";
        print STDERR " linked from ", join(' ', keys(%{$linker{$page}})), "\n";
	$result = 1;
    }
}
exit($result);

sub start {
    my($tagname, $attr) = @_;
    if (($tagname eq 'a' or $tagname eq 'link')
        and defined($attr->{'href'})) {
	my $href = URI->new($attr->{'href'});
	if (defined($href->scheme()) and $href->scheme() eq $myscheme
		and $href->port == 4000) {
		print STDERR "Dev link $href on page $url\n";
		exit(1)
	}
        my $target = URI->new_abs($attr->{'href'}, $url)->canonical();
        $target->fragment(undef);
        $target->query(undef);
        if (($target->scheme() eq $myscheme 
            and $target->port eq $myport
            and $target->host eq $myhost) and
            $target->as_string() !~ /\@/) {
            push(@todo, $target);
            $linker{$target}{$url} = 1;
        }
        if (defined($attr->{'rev'}) and $attr->{'rev'} eq 'made') {
            $mymail = $target->to;
        } elsif (defined($attr->{'rel'}) and $attr->{'rel'} eq 'author') {
            $mymail = $target->to;
        } elsif ($target->scheme() eq 'mailto' and !$mymail) {
            $mymail = $target->to;
        }
    }
}
